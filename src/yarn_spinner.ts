// @generated by protobuf-ts 2.5.0
// @generated from protobuf file "yarn_spinner.proto" (package "Yarn", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * A complete Yarn program.
 *
 * @generated from protobuf message Yarn.Program
 */
export interface Program {
    /**
     * The name of the program.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * The collection of nodes in this program.
     *
     * @generated from protobuf field: map<string, Yarn.Node> nodes = 2;
     */
    nodes: {
        [key: string]: Node;
    };
    /**
     * The collection of initial values for variables; if a PUSH_VARIABLE
     * instruction is run, and the value is not found in the storage, this
     * value will be used
     *
     * @generated from protobuf field: map<string, Yarn.Operand> initial_values = 3;
     */
    initialValues: {
        [key: string]: Operand;
    };
}
/**
 * A collection of instructions
 *
 * @generated from protobuf message Yarn.Node
 */
export interface Node {
    /**
     * The name of this node.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * The list of instructions in this node.
     *
     * @generated from protobuf field: repeated Yarn.Instruction instructions = 2;
     */
    instructions: Instruction[];
    /**
     * A jump table, mapping the names of labels to positions in the
     * instructions list.
     *
     * @generated from protobuf field: map<string, int32> labels = 3;
     */
    labels: {
        [key: string]: number;
    };
    /**
     * The tags associated with this node.
     *
     * @generated from protobuf field: repeated string tags = 4;
     */
    tags: string[];
    /**
     * the entry in the program's string table that contains the original
     * text of this node; null if this is not available
     *
     * @generated from protobuf field: string sourceTextStringID = 5;
     */
    sourceTextStringID: string;
}
/**
 * A single Yarn instruction.
 *
 * @generated from protobuf message Yarn.Instruction
 */
export interface Instruction {
    /**
     * The operation that this instruction will perform.
     *
     * @generated from protobuf field: Yarn.Instruction.OpCode opcode = 1;
     */
    opcode: Instruction_OpCode;
    /**
     * The list of operands, if any, that this instruction uses.
     *
     * @generated from protobuf field: repeated Yarn.Operand operands = 2;
     */
    operands: Operand[];
}
/**
 * The type of instruction that this is.
 *
 * @generated from protobuf enum Yarn.Instruction.OpCode
 */
export enum Instruction_OpCode {
    /**
     * Jumps to a named position in the node.
     * opA = string: label name
     *
     * @generated from protobuf enum value: JUMP_TO = 0;
     */
    JUMP_TO = 0,
    /**
     * Peeks a string from stack, and jumps to that named position in
     * the node.
     * No operands.
     *
     * @generated from protobuf enum value: JUMP = 1;
     */
    JUMP = 1,
    /**
     * Delivers a string ID to the client.
     * opA = string: string ID
     *
     * @generated from protobuf enum value: RUN_LINE = 2;
     */
    RUN_LINE = 2,
    /**
     * Delivers a command to the client.
     * opA = string: command text
     *
     * @generated from protobuf enum value: RUN_COMMAND = 3;
     */
    RUN_COMMAND = 3,
    /**
     * Adds an entry to the option list (see ShowOptions).
     * - opA = string: string ID for option to add
     * - opB = string: destination to go to if this option is selected
     * - opC = number: number of expressions on the stack to insert
     *   into the line
     * - opD = bool: whether the option has a condition on it (in which
     *   case a value should be popped off the stack and used to signal
     *   the game that the option should be not available)
     *
     * @generated from protobuf enum value: ADD_OPTION = 4;
     */
    ADD_OPTION = 4,
    /**
     * Presents the current list of options to the client, then clears
     * the list. The most recently selected option will be on the top
     * of the stack when execution resumes.
     * No operands.
     *
     * @generated from protobuf enum value: SHOW_OPTIONS = 5;
     */
    SHOW_OPTIONS = 5,
    /**
     * Pushes a string onto the stack.
     * opA = string: the string to push to the stack.
     *
     * @generated from protobuf enum value: PUSH_STRING = 6;
     */
    PUSH_STRING = 6,
    /**
     * Pushes a floating point number onto the stack.
     * opA = float: number to push to stack
     *
     * @generated from protobuf enum value: PUSH_FLOAT = 7;
     */
    PUSH_FLOAT = 7,
    /**
     * Pushes a boolean onto the stack.
     * opA = bool: the bool to push to stack
     *
     * @generated from protobuf enum value: PUSH_BOOL = 8;
     */
    PUSH_BOOL = 8,
    /**
     * Pushes a null value onto the stack.
     * No operands.
     *
     * @generated from protobuf enum value: PUSH_NULL = 9;
     */
    PUSH_NULL = 9,
    /**
     * Jumps to the named position in the the node, if the top of the
     * stack is not null, zero or false.
     * opA = string: label name
     *
     * @generated from protobuf enum value: JUMP_IF_FALSE = 10;
     */
    JUMP_IF_FALSE = 10,
    /**
     * Discards top of stack.
     * No operands.
     *
     * @generated from protobuf enum value: POP = 11;
     */
    POP = 11,
    /**
     * Calls a function in the client. Pops as many arguments as the
     * client indicates the function receives, and the result (if any)
     * is pushed to the stack.
     * opA = string: name of the function
     *
     * @generated from protobuf enum value: CALL_FUNC = 12;
     */
    CALL_FUNC = 12,
    /**
     * Pushes the contents of a variable onto the stack.
     * opA = name of variable
     *
     * @generated from protobuf enum value: PUSH_VARIABLE = 13;
     */
    PUSH_VARIABLE = 13,
    /**
     * Stores the contents of the top of the stack in the named
     * variable.
     * opA = name of variable
     *
     * @generated from protobuf enum value: STORE_VARIABLE = 14;
     */
    STORE_VARIABLE = 14,
    /**
     * Stops execution of the program.
     * No operands.
     *
     * @generated from protobuf enum value: STOP = 15;
     */
    STOP = 15,
    /**
     * Pops a string off the top of the stack, and runs the node with
     * that name.
     * No operands.
     *
     * @generated from protobuf enum value: RUN_NODE = 16;
     */
    RUN_NODE = 16
}
/**
 * A value used by an Instruction.
 *
 * @generated from protobuf message Yarn.Operand
 */
export interface Operand {
    /**
     * @generated from protobuf oneof: value
     */
    value: {
        oneofKind: "stringValue";
        /**
         * A string.
         *
         * @generated from protobuf field: string string_value = 1;
         */
        stringValue: string;
    } | {
        oneofKind: "boolValue";
        /**
         * A boolean (true or false).
         *
         * @generated from protobuf field: bool bool_value = 2;
         */
        boolValue: boolean;
    } | {
        oneofKind: "floatValue";
        /**
         * A floating point number.
         *
         * @generated from protobuf field: float float_value = 3;
         */
        floatValue: number;
    } | {
        oneofKind: undefined;
    };
}
// @generated message type with reflection information, may provide speed optimized methods
class Program$Type extends MessageType<Program> {
    constructor() {
        super("Yarn.Program", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "nodes", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Node } },
            { no: 3, name: "initial_values", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Operand } }
        ]);
    }
    create(value?: PartialMessage<Program>): Program {
        const message = { name: "", nodes: {}, initialValues: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Program>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Program): Program {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* map<string, Yarn.Node> nodes */ 2:
                    this.binaryReadMap2(message.nodes, reader, options);
                    break;
                case /* map<string, Yarn.Operand> initial_values */ 3:
                    this.binaryReadMap3(message.initialValues, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: Program["nodes"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Program["nodes"] | undefined, val: Program["nodes"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Node.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field Yarn.Program.nodes");
            }
        }
        map[key ?? ""] = val ?? Node.create();
    }
    private binaryReadMap3(map: Program["initialValues"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Program["initialValues"] | undefined, val: Program["initialValues"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Operand.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field Yarn.Program.initial_values");
            }
        }
        map[key ?? ""] = val ?? Operand.create();
    }
    internalBinaryWrite(message: Program, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* map<string, Yarn.Node> nodes = 2; */
        for (let k of Object.keys(message.nodes)) {
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Node.internalBinaryWrite(message.nodes[k], writer, options);
            writer.join().join();
        }
        /* map<string, Yarn.Operand> initial_values = 3; */
        for (let k of Object.keys(message.initialValues)) {
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Operand.internalBinaryWrite(message.initialValues[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Yarn.Program
 */
export const Program = new Program$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Node$Type extends MessageType<Node> {
    constructor() {
        super("Yarn.Node", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "instructions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Instruction },
            { no: 3, name: "labels", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 5 /*ScalarType.INT32*/ } },
            { no: 4, name: "tags", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "sourceTextStringID", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Node>): Node {
        const message = { name: "", instructions: [], labels: {}, tags: [], sourceTextStringID: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Node>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Node): Node {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* repeated Yarn.Instruction instructions */ 2:
                    message.instructions.push(Instruction.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* map<string, int32> labels */ 3:
                    this.binaryReadMap3(message.labels, reader, options);
                    break;
                case /* repeated string tags */ 4:
                    message.tags.push(reader.string());
                    break;
                case /* string sourceTextStringID */ 5:
                    message.sourceTextStringID = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap3(map: Node["labels"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Node["labels"] | undefined, val: Node["labels"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.int32();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field Yarn.Node.labels");
            }
        }
        map[key ?? ""] = val ?? 0;
    }
    internalBinaryWrite(message: Node, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* repeated Yarn.Instruction instructions = 2; */
        for (let i = 0; i < message.instructions.length; i++)
            Instruction.internalBinaryWrite(message.instructions[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* map<string, int32> labels = 3; */
        for (let k of Object.keys(message.labels))
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.Varint).int32(message.labels[k]).join();
        /* repeated string tags = 4; */
        for (let i = 0; i < message.tags.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.tags[i]);
        /* string sourceTextStringID = 5; */
        if (message.sourceTextStringID !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.sourceTextStringID);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Yarn.Node
 */
export const Node = new Node$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Instruction$Type extends MessageType<Instruction> {
    constructor() {
        super("Yarn.Instruction", [
            { no: 1, name: "opcode", kind: "enum", T: () => ["Yarn.Instruction.OpCode", Instruction_OpCode] },
            { no: 2, name: "operands", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Operand }
        ]);
    }
    create(value?: PartialMessage<Instruction>): Instruction {
        const message = { opcode: 0, operands: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Instruction>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Instruction): Instruction {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Yarn.Instruction.OpCode opcode */ 1:
                    message.opcode = reader.int32();
                    break;
                case /* repeated Yarn.Operand operands */ 2:
                    message.operands.push(Operand.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Instruction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Yarn.Instruction.OpCode opcode = 1; */
        if (message.opcode !== 0)
            writer.tag(1, WireType.Varint).int32(message.opcode);
        /* repeated Yarn.Operand operands = 2; */
        for (let i = 0; i < message.operands.length; i++)
            Operand.internalBinaryWrite(message.operands[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Yarn.Instruction
 */
export const Instruction = new Instruction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Operand$Type extends MessageType<Operand> {
    constructor() {
        super("Yarn.Operand", [
            { no: 1, name: "string_value", kind: "scalar", oneof: "value", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "bool_value", kind: "scalar", oneof: "value", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "float_value", kind: "scalar", oneof: "value", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<Operand>): Operand {
        const message = { value: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Operand>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Operand): Operand {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string string_value */ 1:
                    message.value = {
                        oneofKind: "stringValue",
                        stringValue: reader.string()
                    };
                    break;
                case /* bool bool_value */ 2:
                    message.value = {
                        oneofKind: "boolValue",
                        boolValue: reader.bool()
                    };
                    break;
                case /* float float_value */ 3:
                    message.value = {
                        oneofKind: "floatValue",
                        floatValue: reader.float()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Operand, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string string_value = 1; */
        if (message.value.oneofKind === "stringValue")
            writer.tag(1, WireType.LengthDelimited).string(message.value.stringValue);
        /* bool bool_value = 2; */
        if (message.value.oneofKind === "boolValue")
            writer.tag(2, WireType.Varint).bool(message.value.boolValue);
        /* float float_value = 3; */
        if (message.value.oneofKind === "floatValue")
            writer.tag(3, WireType.Bit32).float(message.value.floatValue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Yarn.Operand
 */
export const Operand = new Operand$Type();
